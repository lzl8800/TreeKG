AggrConfig:
  # —— I/O（名字即可；实际路径由代码拼：HiddenKG/output 或 HiddenKG/logs）—— #
  CONV_IN_NAME: "conv_entities.json"
  OUT_NAME: "aggr_entities.json"
  LOG_NAME: "aggr.log"
  ENCODING: "utf-8"

  # —— LLM 调用 —— #
  TEMPERATURE: 0.0
  MAX_TOKENS: 1000
  API_TIMEOUT: 120
  RETRIES: 3
  CHAT_COMPLETIONS_PATH: "/chat/completions"
  DRY_RUN: 0

  # —— 调试/运行控制 —— #
  LIMIT: 0            # 0 表示不限制；>0 仅处理前 N 个实体
  TREE_ENFORCE: 1     # 是否强制每个 non-core 只有一个父节点
  PROGRESS_NCOLS: 100 # 进度条宽度

  # —— 关系判定与横改纵 —— #
  VERTICAL_REL_TYPES:     # 视为“纵向”的关系前缀（不区分大小写）
    - "has_subordinate"
    - "has_parent"
    - "has_entity"
    - "has_subsection"
  RELATION_TAGS:          # 横改纵时写回去的关系名
    child_of: "has_parent|in"        # non-core -> core（回指）
    parent_of: "has_subordinate|out" # core -> non-core

  # —— 兜底启发式（LLM 失败时）—— #
  FALLBACK:
    threshold: 4          # >= threshold 视为 core
    neighbor_weight: 0.5  # 评分 = 出现次数 + neighbor_weight * 邻居数

  # —— 提示词（可按需修改语气/规则）—— #
  PROMPTS:
    system: |-
      你是知识图谱构建专家。任务：判断给定实体是核心（core）还是非核心（non-core）。
      只基于提供的文本线索做判断，不引入外部常识或猜测。

      判定信号（重要性从高到低）：
      1) 抽象层级/上位性：是否为上位概念/方法论，而非具体命令/参数/按钮/取值。
      2) 结构中心性：是否被多处引用、跨多个小节/章节出现；能否作为前置知识。
      3) 标题/纲要出现：是否出现在章/节标题、综述/定义性段落。
      4) 作用范围：是否跨任务/跨模块可复用（通用概念）。
      5) 粒度与可替代性：能否统摄同级多项；若可被上位词替代则倾向非核心。

      快速决策（满足即停）：
      A. 明显是具体命令/函数/按钮/参数/文件名/格式/具体类型取值 ⇒ non-core
      B. 章/节级概念、关键术语、通用方法/理论/范式 ⇒ core
      C. 同时满足 ≥3 个判定信号 ⇒ core；否则 ⇒ non-core

      输出格式（严格遵守）：
      - 第一行：core 或 non-core（小写、无标点、无多余文字）
      - 第二行（可选）：≤30字，给出最关键的判定理由（中文）
